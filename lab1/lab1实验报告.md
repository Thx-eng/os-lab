# ucore Lab1 实验报告

## 实验目的

本实验主要讲解最小可执行内核和启动流程。通过在Qemu模拟器上运行64位RISC-V计算机环境，学习操作系统内核的正确对接方式，掌握程序内存布局和编译流程相关知识，特别是链接脚本的使用和交叉编译技术。

## 实验内容

实验1主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识,以及通过opensbi固件来通过服务。

## 实验环境

- **模拟器**: Qemu 4.1.1 (riscv64版本)
- **目标架构**: RISC-V 64位
- **调试工具**: GDB
- **编译工具链**: riscv64-unknown-elf-gcc

## 运行结果

进入文件夹，使用make之后进行make qemu，得到：

OpenSBI v0.4 (Jul  2 2019 11:53:53)
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|

Platform Name          : QEMU Virt Machine
Platform HART Features : RV64ACDFIMSU
Platform Max HARTs     : 8
Current Hart           : 0
Firmware Base          : 0x80000000
Firmware Size          : 112 KB
Runtime SBI Version    : 0.1

PMP0: 0x0000000080000000-0x000000008001ffff (A)
PMP1: 0x0000000000000000-0xffffffffffffffff (A,R,W,X)
(THU.CST) os is loading ...

## 练习1：理解内核启动中的程序入口操作

### 指令分析

在`kern/init/entry.S`文件中，我们重点分析两条关键指令：

**la sp, bootstacktop**
asm
la sp, bootstacktop

该指令负责初始化栈指针寄存器。通过将栈顶地址bootstacktop加载到sp寄存器中，为内核建立了运行所需的栈空间环境。栈内存采用从高地址向低地址生长的标准方式，这一操作为后续的函数调用、局部变量存储和中断处理提供了基础支持。

**tail kern_init**
asm
tail kern_init

这是尾调用指令，用于跳转到C语言编写的kern_init函数。与普通函数调用不同，tail调用优化了栈空间使用，不保存返回地址，直接复用当前栈帧。这种设计使内核初始化函数不会返回，无需保留返回信息。

kern_init 函数共有内核初启的核心任务：

初始化内核环境：例如，清理 .bss 段，为未初始化的全局变量赋零值。
向用户提供可视化反馈：这是操作系统与开发者/用户的第一次交互，通过输出信息告诉我们：“os is loading ...”。

## 练习2：使用GDB验证启动流程

### 调试过程

通过GDB调试工具完整跟踪了系统启动过程：

**初始状态检查**

(gdb) target remote localhost:1234
0x8000000000001000 in ?? ()

系统从0x1000地址开始执行，这是RISC-V架构定义的复位向量位置。

**复位指令分析**

(gdb) x/10i 0x1000
0x1000: auipc   t0,0x0
0x1004: addi    a1,t0,32
0x1008: csrr    a0,mhartid
0x100c: ld      t0,24(t0)
0x1010: jr      t0



**练习二问题**

前几条指令的地址：0x1000，随着pc移动不断+4。


前几条指令干了什么：

0x1000:      auipc   t0, 0x0           # 将当前PC的高20位与0相加，存入t0。t0 = 0x1000 + (0 << 12) = 0x1000
0x1004:      addi    a1, t0, 32        # a1 = t0 + 32 = 0x1000 + 32 = 0x1020
0x1008:      csrr    a0, mhartid       # 将当前硬件线程(Hart)的ID读取到寄存器a0
0x100c:      ld      t0, 24(t0)        # 关键！从内存地址 (t0 + 24) = (0x1000 + 24) = 0x1018 处加载一个64位值到t0
0x1010:      jr      t0                # 跳转到t0寄存器所指向的地址

复位代码完成以下功能：
1. 设置运行环境和参数寄存器
2. 读取当前CPU硬件线程ID
3. 加载OpenSBI固件入口地址
4. 跳转到OpenSBI执行
最关键的一步是 0x100c: ld t0, 24(t0)​​。它从地址 0x1018加载一个数据到 t0寄存器。
​​QEMU 的预先设置​​：QEMU 在模拟这台 RISC-V 机器时，已经​​预先在内存地址 0x1018处放置了 OpenSBI 的起始地址 0x80000000​​。
​​加载地址​​：ld t0, 24(t0)执行后，t0寄存器的值就变成了 0x80000000。
​​执行跳转​​：接下来的 jr t0指令使 CPU 开始执行 0x80000000处的代码，也就是 OpenSBI 固件。

两个谜之操作：
​​auipc t0, 0x0​​：是位置无关代码的关键，确保代码可重定位，没有直接mv的用法。
​​csrr a0, mhartid​​：是函数调用的参数准备，遵循标准约定。


**设置断点**

(gdb) x/10i 0x1000
=> 0x1000:      auipc   t0,0x0
   0x1004:      addi    a1,t0,32
   0x1008:      csrr    a0,mhartid
   0x100c:      ld      t0,24(t0)
   0x1010:      jr      t0
   0x1014:      unimp
   0x1016:      unimp
   0x1018:      unimp
   0x101a:      .insn   2, 0x8000
   0x101c:      unimp
(gdb)  b *0x1000
Breakpoint 1 at 0x1000
(gdb) b *0x80200000
Breakpoint 2 at 0x80200000: file kern/init/entry.S, line 7.
(gdb) watch *0x80200000
Hardware watchpoint 3: *0x80200000
(gdb) c
Continuing.

Breakpoint 2, kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop
0
后面几句就是一些占位指令和伪指令。
unimp可能是占位符或对齐填充。
.insn 2, 0x8000可能是某种硬件初始化指令。

随后，我们在0x1000设置断点，随后在0x8002000处设置断点，中间使用continue直接到达，随后输出
Breakpoint 2, kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop
成功在0x80200000地址中断，确认控制权正确移交至内核。
这一句的意思是将栈顶地址bootstacktop加载到sp寄存器中，为内核建立了运行所需的栈空间环境。随后自顶向下生长。



**继续调试**
(gdb) si
0x0000000080200004 in kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop
(gdb) si
9           tail kern_init
(gdb) si
kern_init () at kern/init/init.c:8
8           memset(edata, 0, end - edata);

可以看到开始调用kern_init函数，进入c语言编写的内核入口点。

**寄存器展开的第二次调试**
第一次调试忘记展开寄存器了，再来一次。
寄存器初始状态全是0
如下：
ra             0x0      0x0
sp             0x0      0x0
gp             0x0      0x0
tp             0x0      0x0
t0             0x0      0
t1             0x0      0
t2             0x0      0
fp             0x0      0x0
s1             0x0      0
a0             0x0      0
a1             0x0      0
a2             0x0      0
a3             0x0      0
a4             0x0      0
a5             0x0      0
a6             0x0      0
a7             0x0      0
s2             0x0      0
s3             0x0      0
s4             0x0      0
s5             0x0      0
s6             0x0      0
s7             0x0      0
s8             0x0      0
s9             0x0      0
s10            0x0      0
s11            0x0      0
t3             0x0      0
t4             0x0      0
t5             0x0      0
t6             0x0      0
pc             0x1000   0x1000

执行到0x80000000之后再展开：
(gdb) info registers
ra             0x0      0x0
sp             0x0      0x0
gp             0x0      0x0
tp             0x0      0x0
t0             0x80000000       2147483648
t1             0x0      0
t2             0x0      0
fp             0x0      0x0
s1             0x0      0
a0             0x0      0
a1             0x1020   4128
a2             0x0      0
a3             0x0      0
a4             0x0      0
a5             0x0      0
a6             0x0      0
a7             0x0      0
s2             0x0      0
s3             0x0      0
s4             0x0      0
s5             0x0      0
s6             0x0      0
s7             0x0      0
s8             0x0      0
s9             0x0      0
s10            0x0      0
s11            0x0      0
t3             0x0      0
t4             0x0      0
t5             0x0      0
t6             0x0      0
pc             0x80000000       0x80000000
看到pc完成跳转，t0和a0变化。
此时还未加载出内核。
展开后面几步查看汇编代码：
(gdb) x/20i 0x80000000
   0x80000000:  csrr    a6,mhartid
   0x80000004:  bgtz    a6,0x80000108
   0x80000008:  auipc   t0,0x0
   0x8000000c:  addi    t0,t0,1032
   0x80000010:  auipc   t1,0x0
   0x80000014:  addi    t1,t1,-16
   0x80000018:  sd      t1,0(t0)
   0x8000001c:  auipc   t0,0x0
   0x80000020:  addi    t0,t0,1020
   0x80000024:  ld      t0,0(t0)
   0x80000028:  auipc   t1,0x0
   0x8000002c:  addi    t1,t1,1016
   0x80000030:  ld      t1,0(t1)
   0x80000034:  auipc   t2,0x0
   0x80000038:  addi    t2,t2,988
   0x8000003c:  ld      t2,0(t2)
   0x80000040:  sub     t3,t1,t0
   0x80000044:  add     t3,t3,t2
   0x80000046:  beq     t0,t2,0x8000014e
   0x8000004a:  auipc   t4,0x0
(gdb)
作用:
代码功能解析
​​1. 多核处理与主核确认​​
0x80000000: csrr a6, mhartid    # 读取当前硬件线程ID到a6
0x80000004: bgtz a6, 0x80000108 # 如果不是0号核心(a6>0)，跳转到从核处理程序
​​目的​​：区分主核（Hart 0）和从核（其他Hart）
​​策略​​：只有主核继续执行初始化，从核等待主核完成初始化后唤醒
​​2. 设置异常向量表​​
0x80000008: auipc t0, 0x0       # t0 = 当前PC值 (0x80000008)
0x8000000c: addi t0, t0, 1032   # t0 = 0x80000008 + 1032 = 0x80000410
0x80000010: auipc t1, 0x0       # t1 = 当前PC值 (0x80000010)  
0x80000014: addi t1, t1, -16    # t1 = 0x80000010 - 16 = 0x80000000
0x80000018: sd t1, 0(t0)        # 将0x80000000存入[0x80000410]
​​目的​​：设置mtvec寄存器（异常处理入口）
​​效果​​：确保发生异常时跳转到0x80000000处理
​​3. 加载内存布局信息​​
接下来的代码通过多次auipc/ld组合，加载关键的内存区域信息：
0x8000001c: auipc t0, 0x0       # t0 = 0x8000001c
0x80000020: addi t0, t0, 1020   # t0 = 0x8000001c + 1020 = 0x80000418
0x80000024: ld t0, 0(t0)        # 从[0x80000418]加载数据到t0

0x80000028: auipc t1, 0x0       # t1 = 0x80000028  
0x8000002c: addi t1, t1, 1016   # t1 = 0x80000028 + 1016 = 0x80000420
0x80000030: ld t1, 0(t1)        # 从[0x80000420]加载数据到t1

0x80000034: auipc t2, 0x0       # t2 = 0x80000034
0x80000038: addi t2, t2, 988    # t2 = 0x80000034 + 988 = 0x80000410
0x8000003c: ld t2, 0(t2)        # 从[0x80000410]加载数据到t2
​​加载的内容通常是​​：
t0：代码段起始地址
t1：代码段结束地址
t2：数据段起始地址
​​4. 设置BSS段清零​​
0x80000040: sub t3, t1, t0      # 计算代码段长度
0x80000044: add t3, t3, t2      # 加上数据段偏移
0x80000046: beq t0, t2, 0x8000014e # 如果不需要清零，跳过后续
​​目的​​：准备清零BSS段（未初始化数据段）
​​计算​​：确定需要清零的内存范围

总结一下就是在干什么事呢？就是在加载OPENSBI的初始环境，确保能够正常运行。包括异常处理、内存布局、BSS段清零这些基础工作。

继续进行完刚才的调试到达0x80200000，再展开得到：

(gdb) info registers
ra             0x80000a02       0x80000a02
sp             0x80203000       0x80203000 <SBI_CONSOLE_PUTCHAR>
gp             0x0      0x0
tp             0x8001be00       0x8001be00
t0             0x80200000       2149580800
t1             0x1      1
t2             0x1      1
fp             0x8001bd90       0x8001bd90
s1             0x8001be00       2147597824
a0             0x0      0
a1             0x82200000       2183135232
a2             0x80200000       2149580800
a3             0x1      1
a4             0x800    2048
a5             0x1      1
a6             0x82200000       2183135232
a7             0x80200000       2149580800
s2             0x800095c0       2147521984
s3             0x0      0
s4             0x0      0
s5             0x0      0
s6             0x0      0
s7             0x8      8
s8             0x2000   8192
s9             0x0      0
s10            0x0      0
s11            0x0      0
t3             0x0      0
t4             0x0      0
t5             0x0      0
t6             0x82200000       2183135232
pc             0x8020000a       0x8020000a <kern_init>
(gdb) x/10i $pc
目前从0x8020000进行了三部单步调试，现在pc指针在0x8020000a

(gdb) b *0x80200080
Breakpoint 6 at 0x80200080: file kern/libs/stdio.c, line 43.
(gdb) watch *0x80200080
Hardware watchpoint 7: *0x80200080
(gdb) c
Continuing.
此时大屏幕上图标已经显现，只剩下“(THU.CST) os is loading ...”这句话没有输出。
再随便打一个断点
Breakpoint 6, cprintf (fmt=fmt@entry=0x802004c8 "%s\n\n")
    at kern/libs/stdio.c:43
43          return cnt;

“(THU.CST) os is loading ...”已输出。

(gdb) x/20i 0x80200000
=> 0x80200000 <kern_entry>:     auipc   sp,0x3
   0x80200004 <kern_entry+4>:   mv      sp,sp
   0x80200008 <kern_entry+8>:   j       0x8020000a <kern_init>
   0x8020000a <kern_init>:      auipc   a0,0x3
   0x8020000e <kern_init+4>:    addi    a0,a0,-2
   0x80200012 <kern_init+8>:    auipc   a2,0x3
   0x80200016 <kern_init+12>:   addi    a2,a2,-10
   0x8020001a <kern_init+16>:   addi    sp,sp,-16
   0x8020001c <kern_init+18>:   li      a1,0
   0x8020001e <kern_init+20>:   sub     a2,a2,a0
   0x80200020 <kern_init+22>:   sd      ra,8(sp)
   0x80200022 <kern_init+24>:   jal     0x80200490 <memset>
   0x80200026 <kern_init+28>:   auipc   a1,0x0
   0x8020002a <kern_init+32>:   addi    a1,a1,1154
   0x8020002e <kern_init+36>:   auipc   a0,0x0
   0x80200032 <kern_init+40>:   addi    a0,a0,1178
   0x80200036 <kern_init+44>:   jal     0x80200054 <cprintf>
   0x8020003a <kern_init+48>:   j       0x8020003a <kern_init+48>
   0x8020003c <cputch>: addi    sp,sp,-32
   0x8020003e <cputch+2>:       sd      ra,24(sp)
(gdb)
可以看到，0x802000a已经进入已进入kern_init函数，c语言的内容。而0x80200054是输出函数。




### 实验中的重要知识点

## 本实验中重要的知识点，以及与对应的OS原理中的知识点
| 实验中的知识点 | 对应的OS原理知识点 | 理解与阐述 |
|----------------|--------------------|-------------|
| **QEMU启动与硬件复位** | 计算机体系结构、引导 | **含义：** 实验中CPU从固定的复位地址`0x1000`开始执行。OS原理中，这是计算机启动的起点，是硬件定义的行为。<br>**关系：** 实验的具体流程（`0x1000 -> OpenSBI -> Kernel`）是引导原理的一个实例。<br>**差异：** 实验环境（QEMU）简化了流程，真实PC的引导过程（UEFI/BIOS）要复杂得多，涉及加电自检（POST）、设备枚举等。 |
| **链接脚本 (kernel.ld)** | 程序内存布局、链接与加载 | **含义：** 实验中用链接脚本精确控制内核代码段、数据段等在内存中的物理地址（`0x80200000`）。OS原理中，这涉及到可执行文件的结构和操作系统如何加载程序到内存。<br>**关系：** 链接脚本是实现指定内存布局的工具。内核首先要为自己布局，然后才能为用户进程进行布局。<br>**差异：** 内核的布局是针对物理地址的，且是静态的。而OS原理中常讨论的用户进程内存布局是针对虚拟地址的，更灵活，由操作系统在运行时动态管理。 |
| **特权级（M-mode, S-mode）** | 保护机制、双模式操作 | **含义：** 实验中OpenSBI运行在M-mode，内核运行在S-mode。这是硬件提供的隔离机制。<br>**关系：** OS原理中，双模式（用户态/内核态）是保护操作系统内核不受用户程序破坏的核心机制。M/S-mode是RISC-V对双模式思想的实现。<br>**差异：** 实验中我们关注的是固件与内核的接口，而OS原理更常强调内核与用户程序的接口。但其背后的保护思想是完全一致的。 |
| **SBI调用 (ecall)** | 系统调用、中断与异常 | **含义：** 内核通过`ecall`指令从S-mode陷入M-mode，请求OpenSBI提供的服务（如打印字符）。这是受控的权限提升。<br>**关系：** 实验中的SBI调用和OS原理中的系统调用是完全相同的底层机制，都是通过陷阱（trap）安全地跨越权限边界请求服务。<br>**差异：** 服务提供者不同。SBI调用的服务提供者是固件（OpenSBI），系统调用的服务提供者是操作系统内核。 |
| **交叉编译** | (无直接对应的OS原理知识点) | **含义：** 在一个平台（如x86 Linux）上，编译生成能在另一个平台（RISC-V）上运行的代码。这是嵌入式和操作系统开发的基本技能。 |
| **GDB调试** | (无直接对应的OS原理知识点) | **含义：** 使用GDB远程调试在QEMU中运行的内核，可以观察寄存器、内存，设置断点，单步执行。 |

## OS原理中很重要，但在实验中没有对应上的知识点

### 进程管理

实验中内核仅单线程执行，内核初始化之后直接进入死循环，无进程创建、调度、上下文切换

1. 进程定义

进程是程序的运行实体，是动态执行的过程，包含程序、数据和进程控制块（PCB）；程序是静态的指令集合，可永久存储，一个程序可对应多个进程，一个进程可包含多个程序（如调用多个库函数）。

PCB：内核维护的核心数据结构，记录进程状态、PID、寄存器组、内存地址空间、文件描述符等关键信息，所有进程的 PCB 以链表 / 表格形式组织，PCB 表大小决定了系统的并发度。

2. 并发与并行

- 并行：多个任务在同一时间同时运行，需多硬件支持例如多核 CPU、多机集群等。

- 并发：微观上同一时刻仅一个任务运行，宏观上多个任务依赖进程切换交替推进，通过 “分时共享”（交替速度足够快）模拟 “同时运行”。

并发的意义：程序交替使用 CPU 与 I/O 设备（如 CPU 计算时，I/O 设备可处理其他任务），以此能够提升资源利用率。

3. 进程切换与上下文

- 进程切换：暂停当前CPU上运行的进程，并从就绪队列里选择另一个进程继续运行，核心是 “保存上下文” 与 “恢复上下文”。

- 上下文（Context）：进程运行状态的集合，包括 CPU 寄存器（PC 程序计数器、SP 栈指针等）、CPU 状态（特权级、中断屏蔽字）、内存地址空间（页表、段表）。

- 切换实现：通过硬件指令（如 MIPS 的switch_to函数）保存当前进程寄存器到 PCB，从目标进程 PCB 恢复寄存器，完成切换。

4. 进程调度

- 调度时机：时间片耗尽、进程阻塞（如 I/O 等待）、高优先级进程唤醒、进程终止。

- 调度算法：
调度算法需平衡公平性、吞吐量、响应时间等指标，常见算法包括：

    - 时间片轮转：为每个进程分配固定时间片，轮流执行。
    - 优先级调度：优先调度高优先级进程（如系统进程优先级高于用户进程），支持抢占式（高优先级进程可打断低优先级进程）和非抢占式。
    - 多级反馈队列：结合时间片与优先级，高优先级队列时间片短（如 1ms），低优先级队列时间片长（如 100ms），进程根据运行情况在队列间迁移，若执行时间长则可降级。

- 调度数据结构：需维护就绪队列（存放可运行进程）、阻塞队列（存放等待事件的进程），通过 PCB 链表或优先队列管理进程。